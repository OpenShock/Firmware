// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HUBTOLOCALMESSAGE_OPENSHOCK_SERIALIZATION_LOCAL_H_
#define FLATBUFFERS_GENERATED_HUBTOLOCALMESSAGE_OPENSHOCK_SERIALIZATION_LOCAL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "HubConfig_generated.h"
#include "WifiNetwork_generated.h"
#include "WifiNetworkEventType_generated.h"
#include "WifiScanStatus_generated.h"

namespace OpenShock {
namespace Serialization {
namespace Local {

struct ReadyMessage;
struct ReadyMessageBuilder;

struct ErrorMessage;
struct ErrorMessageBuilder;

struct WifiScanStatusMessage;
struct WifiScanStatusMessageBuilder;

struct WifiNetworkEvent;
struct WifiNetworkEventBuilder;

struct WifiGotIpEvent;
struct WifiGotIpEventBuilder;

struct WifiLostIpEvent;
struct WifiLostIpEventBuilder;

struct AccountLinkCommandResult;
struct AccountLinkCommandResultBuilder;

struct SetRfTxPinCommandResult;
struct SetRfTxPinCommandResultBuilder;

struct SetEstopEnabledCommandResult;
struct SetEstopEnabledCommandResultBuilder;

struct SetEstopPinCommandResult;
struct SetEstopPinCommandResultBuilder;

struct HubToLocalMessage;
struct HubToLocalMessageBuilder;

enum class AccountLinkResultCode : uint8_t {
  Success = 0,
  CodeRequired = 1,
  InvalidCodeLength = 2,
  NoInternetConnection = 3,
  InvalidCode = 4,
  RateLimited = 5,
  InternalError = 6,
  MIN = Success,
  MAX = InternalError
};

inline const AccountLinkResultCode (&EnumValuesAccountLinkResultCode())[7] {
  static const AccountLinkResultCode values[] = {
    AccountLinkResultCode::Success,
    AccountLinkResultCode::CodeRequired,
    AccountLinkResultCode::InvalidCodeLength,
    AccountLinkResultCode::NoInternetConnection,
    AccountLinkResultCode::InvalidCode,
    AccountLinkResultCode::RateLimited,
    AccountLinkResultCode::InternalError
  };
  return values;
}

inline const char * const *EnumNamesAccountLinkResultCode() {
  static const char * const names[8] = {
    "Success",
    "CodeRequired",
    "InvalidCodeLength",
    "NoInternetConnection",
    "InvalidCode",
    "RateLimited",
    "InternalError",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccountLinkResultCode(AccountLinkResultCode e) {
  if (::flatbuffers::IsOutRange(e, AccountLinkResultCode::Success, AccountLinkResultCode::InternalError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAccountLinkResultCode()[index];
}

enum class SetGPIOResultCode : uint8_t {
  Success = 0,
  InvalidPin = 1,
  InternalError = 2,
  MIN = Success,
  MAX = InternalError
};

inline const SetGPIOResultCode (&EnumValuesSetGPIOResultCode())[3] {
  static const SetGPIOResultCode values[] = {
    SetGPIOResultCode::Success,
    SetGPIOResultCode::InvalidPin,
    SetGPIOResultCode::InternalError
  };
  return values;
}

inline const char * const *EnumNamesSetGPIOResultCode() {
  static const char * const names[4] = {
    "Success",
    "InvalidPin",
    "InternalError",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetGPIOResultCode(SetGPIOResultCode e) {
  if (::flatbuffers::IsOutRange(e, SetGPIOResultCode::Success, SetGPIOResultCode::InternalError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSetGPIOResultCode()[index];
}

enum class HubToLocalMessagePayload : uint8_t {
  NONE = 0,
  ReadyMessage = 1,
  ErrorMessage = 2,
  WifiScanStatusMessage = 3,
  WifiNetworkEvent = 4,
  WifiGotIpEvent = 5,
  WifiLostIpEvent = 6,
  AccountLinkCommandResult = 7,
  SetRfTxPinCommandResult = 8,
  SetEstopEnabledCommandResult = 9,
  SetEstopPinCommandResult = 10,
  MIN = NONE,
  MAX = SetEstopPinCommandResult
};

inline const HubToLocalMessagePayload (&EnumValuesHubToLocalMessagePayload())[11] {
  static const HubToLocalMessagePayload values[] = {
    HubToLocalMessagePayload::NONE,
    HubToLocalMessagePayload::ReadyMessage,
    HubToLocalMessagePayload::ErrorMessage,
    HubToLocalMessagePayload::WifiScanStatusMessage,
    HubToLocalMessagePayload::WifiNetworkEvent,
    HubToLocalMessagePayload::WifiGotIpEvent,
    HubToLocalMessagePayload::WifiLostIpEvent,
    HubToLocalMessagePayload::AccountLinkCommandResult,
    HubToLocalMessagePayload::SetRfTxPinCommandResult,
    HubToLocalMessagePayload::SetEstopEnabledCommandResult,
    HubToLocalMessagePayload::SetEstopPinCommandResult
  };
  return values;
}

inline const char * const *EnumNamesHubToLocalMessagePayload() {
  static const char * const names[12] = {
    "NONE",
    "ReadyMessage",
    "ErrorMessage",
    "WifiScanStatusMessage",
    "WifiNetworkEvent",
    "WifiGotIpEvent",
    "WifiLostIpEvent",
    "AccountLinkCommandResult",
    "SetRfTxPinCommandResult",
    "SetEstopEnabledCommandResult",
    "SetEstopPinCommandResult",
    nullptr
  };
  return names;
}

inline const char *EnumNameHubToLocalMessagePayload(HubToLocalMessagePayload e) {
  if (::flatbuffers::IsOutRange(e, HubToLocalMessagePayload::NONE, HubToLocalMessagePayload::SetEstopPinCommandResult)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHubToLocalMessagePayload()[index];
}

template<typename T> struct HubToLocalMessagePayloadTraits {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::NONE;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::ReadyMessage> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::ReadyMessage;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::ErrorMessage> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::ErrorMessage;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiScanStatusMessage> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::WifiScanStatusMessage;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiNetworkEvent> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::WifiNetworkEvent;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiGotIpEvent> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::WifiGotIpEvent;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::WifiLostIpEvent> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::WifiLostIpEvent;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::AccountLinkCommandResult> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::AccountLinkCommandResult;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::SetRfTxPinCommandResult> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::SetRfTxPinCommandResult;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::SetEstopEnabledCommandResult> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::SetEstopEnabledCommandResult;
};

template<> struct HubToLocalMessagePayloadTraits<OpenShock::Serialization::Local::SetEstopPinCommandResult> {
  static const HubToLocalMessagePayload enum_value = HubToLocalMessagePayload::SetEstopPinCommandResult;
};

bool VerifyHubToLocalMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, HubToLocalMessagePayload type);
bool VerifyHubToLocalMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<HubToLocalMessagePayload> *types);

struct ReadyMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadyMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.ReadyMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POGGIES = 4,
    VT_CONNECTED_WIFI = 6,
    VT_ACCOUNT_LINKED = 8,
    VT_CONFIG = 10,
    VT_GPIO_VALID_INPUTS = 12,
    VT_GPIO_VALID_OUTPUTS = 14
  };
  bool poggies() const {
    return GetField<uint8_t>(VT_POGGIES, 0) != 0;
  }
  const OpenShock::Serialization::Types::WifiNetwork *connected_wifi() const {
    return GetPointer<const OpenShock::Serialization::Types::WifiNetwork *>(VT_CONNECTED_WIFI);
  }
  bool account_linked() const {
    return GetField<uint8_t>(VT_ACCOUNT_LINKED, 0) != 0;
  }
  const OpenShock::Serialization::Configuration::HubConfig *config() const {
    return GetPointer<const OpenShock::Serialization::Configuration::HubConfig *>(VT_CONFIG);
  }
  const ::flatbuffers::Vector<int8_t> *gpio_valid_inputs() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_GPIO_VALID_INPUTS);
  }
  const ::flatbuffers::Vector<int8_t> *gpio_valid_outputs() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_GPIO_VALID_OUTPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_POGGIES, 1) &&
           VerifyOffset(verifier, VT_CONNECTED_WIFI) &&
           verifier.VerifyTable(connected_wifi()) &&
           VerifyField<uint8_t>(verifier, VT_ACCOUNT_LINKED, 1) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           VerifyOffset(verifier, VT_GPIO_VALID_INPUTS) &&
           verifier.VerifyVector(gpio_valid_inputs()) &&
           VerifyOffset(verifier, VT_GPIO_VALID_OUTPUTS) &&
           verifier.VerifyVector(gpio_valid_outputs()) &&
           verifier.EndTable();
  }
};

struct ReadyMessageBuilder {
  typedef ReadyMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_poggies(bool poggies) {
    fbb_.AddElement<uint8_t>(ReadyMessage::VT_POGGIES, static_cast<uint8_t>(poggies), 0);
  }
  void add_connected_wifi(::flatbuffers::Offset<OpenShock::Serialization::Types::WifiNetwork> connected_wifi) {
    fbb_.AddOffset(ReadyMessage::VT_CONNECTED_WIFI, connected_wifi);
  }
  void add_account_linked(bool account_linked) {
    fbb_.AddElement<uint8_t>(ReadyMessage::VT_ACCOUNT_LINKED, static_cast<uint8_t>(account_linked), 0);
  }
  void add_config(::flatbuffers::Offset<OpenShock::Serialization::Configuration::HubConfig> config) {
    fbb_.AddOffset(ReadyMessage::VT_CONFIG, config);
  }
  void add_gpio_valid_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> gpio_valid_inputs) {
    fbb_.AddOffset(ReadyMessage::VT_GPIO_VALID_INPUTS, gpio_valid_inputs);
  }
  void add_gpio_valid_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> gpio_valid_outputs) {
    fbb_.AddOffset(ReadyMessage::VT_GPIO_VALID_OUTPUTS, gpio_valid_outputs);
  }
  explicit ReadyMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadyMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadyMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadyMessage> CreateReadyMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool poggies = false,
    ::flatbuffers::Offset<OpenShock::Serialization::Types::WifiNetwork> connected_wifi = 0,
    bool account_linked = false,
    ::flatbuffers::Offset<OpenShock::Serialization::Configuration::HubConfig> config = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> gpio_valid_inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> gpio_valid_outputs = 0) {
  ReadyMessageBuilder builder_(_fbb);
  builder_.add_gpio_valid_outputs(gpio_valid_outputs);
  builder_.add_gpio_valid_inputs(gpio_valid_inputs);
  builder_.add_config(config);
  builder_.add_connected_wifi(connected_wifi);
  builder_.add_account_linked(account_linked);
  builder_.add_poggies(poggies);
  return builder_.Finish();
}

struct ReadyMessage::Traits {
  using type = ReadyMessage;
  static auto constexpr Create = CreateReadyMessage;
};

inline ::flatbuffers::Offset<ReadyMessage> CreateReadyMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool poggies = false,
    ::flatbuffers::Offset<OpenShock::Serialization::Types::WifiNetwork> connected_wifi = 0,
    bool account_linked = false,
    ::flatbuffers::Offset<OpenShock::Serialization::Configuration::HubConfig> config = 0,
    const std::vector<int8_t> *gpio_valid_inputs = nullptr,
    const std::vector<int8_t> *gpio_valid_outputs = nullptr) {
  auto gpio_valid_inputs__ = gpio_valid_inputs ? _fbb.CreateVector<int8_t>(*gpio_valid_inputs) : 0;
  auto gpio_valid_outputs__ = gpio_valid_outputs ? _fbb.CreateVector<int8_t>(*gpio_valid_outputs) : 0;
  return OpenShock::Serialization::Local::CreateReadyMessage(
      _fbb,
      poggies,
      connected_wifi,
      account_linked,
      config,
      gpio_valid_inputs__,
      gpio_valid_outputs__);
}

struct ErrorMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.ErrorMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4
  };
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ErrorMessageBuilder {
  typedef ErrorMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(ErrorMessage::VT_MESSAGE, message);
  }
  explicit ErrorMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ErrorMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ErrorMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ErrorMessage> CreateErrorMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  ErrorMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

struct ErrorMessage::Traits {
  using type = ErrorMessage;
  static auto constexpr Create = CreateErrorMessage;
};

inline ::flatbuffers::Offset<ErrorMessage> CreateErrorMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return OpenShock::Serialization::Local::CreateErrorMessage(
      _fbb,
      message__);
}

struct WifiScanStatusMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiScanStatusMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiScanStatusMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4
  };
  OpenShock::Serialization::Types::WifiScanStatus status() const {
    return static_cast<OpenShock::Serialization::Types::WifiScanStatus>(GetField<uint8_t>(VT_STATUS, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           verifier.EndTable();
  }
};

struct WifiScanStatusMessageBuilder {
  typedef WifiScanStatusMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(OpenShock::Serialization::Types::WifiScanStatus status) {
    fbb_.AddElement<uint8_t>(WifiScanStatusMessage::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  explicit WifiScanStatusMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiScanStatusMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiScanStatusMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiScanStatusMessage> CreateWifiScanStatusMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Types::WifiScanStatus status = OpenShock::Serialization::Types::WifiScanStatus::Started) {
  WifiScanStatusMessageBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

struct WifiScanStatusMessage::Traits {
  using type = WifiScanStatusMessage;
  static auto constexpr Create = CreateWifiScanStatusMessage;
};

struct WifiNetworkEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiNetworkEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiNetworkEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_NETWORKS = 6
  };
  OpenShock::Serialization::Types::WifiNetworkEventType event_type() const {
    return static_cast<OpenShock::Serialization::Types::WifiNetworkEventType>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<OpenShock::Serialization::Types::WifiNetwork>> *networks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<OpenShock::Serialization::Types::WifiNetwork>> *>(VT_NETWORKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_NETWORKS) &&
           verifier.VerifyVector(networks()) &&
           verifier.VerifyVectorOfTables(networks()) &&
           verifier.EndTable();
  }
};

struct WifiNetworkEventBuilder {
  typedef WifiNetworkEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(OpenShock::Serialization::Types::WifiNetworkEventType event_type) {
    fbb_.AddElement<uint8_t>(WifiNetworkEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_networks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OpenShock::Serialization::Types::WifiNetwork>>> networks) {
    fbb_.AddOffset(WifiNetworkEvent::VT_NETWORKS, networks);
  }
  explicit WifiNetworkEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiNetworkEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiNetworkEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiNetworkEvent> CreateWifiNetworkEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Types::WifiNetworkEventType event_type = OpenShock::Serialization::Types::WifiNetworkEventType::Discovered,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OpenShock::Serialization::Types::WifiNetwork>>> networks = 0) {
  WifiNetworkEventBuilder builder_(_fbb);
  builder_.add_networks(networks);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

struct WifiNetworkEvent::Traits {
  using type = WifiNetworkEvent;
  static auto constexpr Create = CreateWifiNetworkEvent;
};

inline ::flatbuffers::Offset<WifiNetworkEvent> CreateWifiNetworkEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Types::WifiNetworkEventType event_type = OpenShock::Serialization::Types::WifiNetworkEventType::Discovered,
    const std::vector<::flatbuffers::Offset<OpenShock::Serialization::Types::WifiNetwork>> *networks = nullptr) {
  auto networks__ = networks ? _fbb.CreateVector<::flatbuffers::Offset<OpenShock::Serialization::Types::WifiNetwork>>(*networks) : 0;
  return OpenShock::Serialization::Local::CreateWifiNetworkEvent(
      _fbb,
      event_type,
      networks__);
}

struct WifiGotIpEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiGotIpEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiGotIpEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IP = 4
  };
  const ::flatbuffers::String *ip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           verifier.EndTable();
  }
};

struct WifiGotIpEventBuilder {
  typedef WifiGotIpEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ip(::flatbuffers::Offset<::flatbuffers::String> ip) {
    fbb_.AddOffset(WifiGotIpEvent::VT_IP, ip);
  }
  explicit WifiGotIpEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiGotIpEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiGotIpEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiGotIpEvent> CreateWifiGotIpEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ip = 0) {
  WifiGotIpEventBuilder builder_(_fbb);
  builder_.add_ip(ip);
  return builder_.Finish();
}

struct WifiGotIpEvent::Traits {
  using type = WifiGotIpEvent;
  static auto constexpr Create = CreateWifiGotIpEvent;
};

inline ::flatbuffers::Offset<WifiGotIpEvent> CreateWifiGotIpEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ip = nullptr) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  return OpenShock::Serialization::Local::CreateWifiGotIpEvent(
      _fbb,
      ip__);
}

struct WifiLostIpEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WifiLostIpEventBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.WifiLostIpEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IP = 4
  };
  const ::flatbuffers::String *ip() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           verifier.EndTable();
  }
};

struct WifiLostIpEventBuilder {
  typedef WifiLostIpEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ip(::flatbuffers::Offset<::flatbuffers::String> ip) {
    fbb_.AddOffset(WifiLostIpEvent::VT_IP, ip);
  }
  explicit WifiLostIpEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WifiLostIpEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WifiLostIpEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WifiLostIpEvent> CreateWifiLostIpEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ip = 0) {
  WifiLostIpEventBuilder builder_(_fbb);
  builder_.add_ip(ip);
  return builder_.Finish();
}

struct WifiLostIpEvent::Traits {
  using type = WifiLostIpEvent;
  static auto constexpr Create = CreateWifiLostIpEvent;
};

inline ::flatbuffers::Offset<WifiLostIpEvent> CreateWifiLostIpEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ip = nullptr) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  return OpenShock::Serialization::Local::CreateWifiLostIpEvent(
      _fbb,
      ip__);
}

struct AccountLinkCommandResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccountLinkCommandResultBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.AccountLinkCommandResult";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  OpenShock::Serialization::Local::AccountLinkResultCode result() const {
    return static_cast<OpenShock::Serialization::Local::AccountLinkResultCode>(GetField<uint8_t>(VT_RESULT, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT, 1) &&
           verifier.EndTable();
  }
};

struct AccountLinkCommandResultBuilder {
  typedef AccountLinkCommandResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(OpenShock::Serialization::Local::AccountLinkResultCode result) {
    fbb_.AddElement<uint8_t>(AccountLinkCommandResult::VT_RESULT, static_cast<uint8_t>(result), 0);
  }
  explicit AccountLinkCommandResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccountLinkCommandResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccountLinkCommandResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AccountLinkCommandResult> CreateAccountLinkCommandResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Local::AccountLinkResultCode result = OpenShock::Serialization::Local::AccountLinkResultCode::Success) {
  AccountLinkCommandResultBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct AccountLinkCommandResult::Traits {
  using type = AccountLinkCommandResult;
  static auto constexpr Create = CreateAccountLinkCommandResult;
};

struct SetRfTxPinCommandResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetRfTxPinCommandResultBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.SetRfTxPinCommandResult";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PIN = 4,
    VT_RESULT = 6
  };
  int8_t pin() const {
    return GetField<int8_t>(VT_PIN, 0);
  }
  OpenShock::Serialization::Local::SetGPIOResultCode result() const {
    return static_cast<OpenShock::Serialization::Local::SetGPIOResultCode>(GetField<uint8_t>(VT_RESULT, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_RESULT, 1) &&
           verifier.EndTable();
  }
};

struct SetRfTxPinCommandResultBuilder {
  typedef SetRfTxPinCommandResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pin(int8_t pin) {
    fbb_.AddElement<int8_t>(SetRfTxPinCommandResult::VT_PIN, pin, 0);
  }
  void add_result(OpenShock::Serialization::Local::SetGPIOResultCode result) {
    fbb_.AddElement<uint8_t>(SetRfTxPinCommandResult::VT_RESULT, static_cast<uint8_t>(result), 0);
  }
  explicit SetRfTxPinCommandResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetRfTxPinCommandResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetRfTxPinCommandResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetRfTxPinCommandResult> CreateSetRfTxPinCommandResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t pin = 0,
    OpenShock::Serialization::Local::SetGPIOResultCode result = OpenShock::Serialization::Local::SetGPIOResultCode::Success) {
  SetRfTxPinCommandResultBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_pin(pin);
  return builder_.Finish();
}

struct SetRfTxPinCommandResult::Traits {
  using type = SetRfTxPinCommandResult;
  static auto constexpr Create = CreateSetRfTxPinCommandResult;
};

struct SetEstopEnabledCommandResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetEstopEnabledCommandResultBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.SetEstopEnabledCommandResult";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLED = 4,
    VT_SUCCESS = 6
  };
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
};

struct SetEstopEnabledCommandResultBuilder {
  typedef SetEstopEnabledCommandResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(SetEstopEnabledCommandResult::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SetEstopEnabledCommandResult::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit SetEstopEnabledCommandResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetEstopEnabledCommandResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetEstopEnabledCommandResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetEstopEnabledCommandResult> CreateSetEstopEnabledCommandResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool enabled = false,
    bool success = false) {
  SetEstopEnabledCommandResultBuilder builder_(_fbb);
  builder_.add_success(success);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct SetEstopEnabledCommandResult::Traits {
  using type = SetEstopEnabledCommandResult;
  static auto constexpr Create = CreateSetEstopEnabledCommandResult;
};

struct SetEstopPinCommandResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetEstopPinCommandResultBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.SetEstopPinCommandResult";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GPIO_PIN = 4,
    VT_RESULT = 6
  };
  int8_t gpio_pin() const {
    return GetField<int8_t>(VT_GPIO_PIN, 0);
  }
  OpenShock::Serialization::Local::SetGPIOResultCode result() const {
    return static_cast<OpenShock::Serialization::Local::SetGPIOResultCode>(GetField<uint8_t>(VT_RESULT, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_GPIO_PIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_RESULT, 1) &&
           verifier.EndTable();
  }
};

struct SetEstopPinCommandResultBuilder {
  typedef SetEstopPinCommandResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gpio_pin(int8_t gpio_pin) {
    fbb_.AddElement<int8_t>(SetEstopPinCommandResult::VT_GPIO_PIN, gpio_pin, 0);
  }
  void add_result(OpenShock::Serialization::Local::SetGPIOResultCode result) {
    fbb_.AddElement<uint8_t>(SetEstopPinCommandResult::VT_RESULT, static_cast<uint8_t>(result), 0);
  }
  explicit SetEstopPinCommandResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetEstopPinCommandResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetEstopPinCommandResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetEstopPinCommandResult> CreateSetEstopPinCommandResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t gpio_pin = 0,
    OpenShock::Serialization::Local::SetGPIOResultCode result = OpenShock::Serialization::Local::SetGPIOResultCode::Success) {
  SetEstopPinCommandResultBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_gpio_pin(gpio_pin);
  return builder_.Finish();
}

struct SetEstopPinCommandResult::Traits {
  using type = SetEstopPinCommandResult;
  static auto constexpr Create = CreateSetEstopPinCommandResult;
};

struct HubToLocalMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HubToLocalMessageBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "OpenShock.Serialization.Local.HubToLocalMessage";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_TYPE = 4,
    VT_PAYLOAD = 6
  };
  OpenShock::Serialization::Local::HubToLocalMessagePayload payload_type() const {
    return static_cast<OpenShock::Serialization::Local::HubToLocalMessagePayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const OpenShock::Serialization::Local::ReadyMessage *payload_as_ReadyMessage() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::ReadyMessage ? static_cast<const OpenShock::Serialization::Local::ReadyMessage *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::ErrorMessage *payload_as_ErrorMessage() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::ErrorMessage ? static_cast<const OpenShock::Serialization::Local::ErrorMessage *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiScanStatusMessage *payload_as_WifiScanStatusMessage() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::WifiScanStatusMessage ? static_cast<const OpenShock::Serialization::Local::WifiScanStatusMessage *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiNetworkEvent *payload_as_WifiNetworkEvent() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::WifiNetworkEvent ? static_cast<const OpenShock::Serialization::Local::WifiNetworkEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiGotIpEvent *payload_as_WifiGotIpEvent() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::WifiGotIpEvent ? static_cast<const OpenShock::Serialization::Local::WifiGotIpEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::WifiLostIpEvent *payload_as_WifiLostIpEvent() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::WifiLostIpEvent ? static_cast<const OpenShock::Serialization::Local::WifiLostIpEvent *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::AccountLinkCommandResult *payload_as_AccountLinkCommandResult() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::AccountLinkCommandResult ? static_cast<const OpenShock::Serialization::Local::AccountLinkCommandResult *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::SetRfTxPinCommandResult *payload_as_SetRfTxPinCommandResult() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::SetRfTxPinCommandResult ? static_cast<const OpenShock::Serialization::Local::SetRfTxPinCommandResult *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::SetEstopEnabledCommandResult *payload_as_SetEstopEnabledCommandResult() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::SetEstopEnabledCommandResult ? static_cast<const OpenShock::Serialization::Local::SetEstopEnabledCommandResult *>(payload()) : nullptr;
  }
  const OpenShock::Serialization::Local::SetEstopPinCommandResult *payload_as_SetEstopPinCommandResult() const {
    return payload_type() == OpenShock::Serialization::Local::HubToLocalMessagePayload::SetEstopPinCommandResult ? static_cast<const OpenShock::Serialization::Local::SetEstopPinCommandResult *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyHubToLocalMessagePayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const OpenShock::Serialization::Local::ReadyMessage *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::ReadyMessage>() const {
  return payload_as_ReadyMessage();
}

template<> inline const OpenShock::Serialization::Local::ErrorMessage *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::ErrorMessage>() const {
  return payload_as_ErrorMessage();
}

template<> inline const OpenShock::Serialization::Local::WifiScanStatusMessage *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiScanStatusMessage>() const {
  return payload_as_WifiScanStatusMessage();
}

template<> inline const OpenShock::Serialization::Local::WifiNetworkEvent *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiNetworkEvent>() const {
  return payload_as_WifiNetworkEvent();
}

template<> inline const OpenShock::Serialization::Local::WifiGotIpEvent *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiGotIpEvent>() const {
  return payload_as_WifiGotIpEvent();
}

template<> inline const OpenShock::Serialization::Local::WifiLostIpEvent *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::WifiLostIpEvent>() const {
  return payload_as_WifiLostIpEvent();
}

template<> inline const OpenShock::Serialization::Local::AccountLinkCommandResult *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::AccountLinkCommandResult>() const {
  return payload_as_AccountLinkCommandResult();
}

template<> inline const OpenShock::Serialization::Local::SetRfTxPinCommandResult *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::SetRfTxPinCommandResult>() const {
  return payload_as_SetRfTxPinCommandResult();
}

template<> inline const OpenShock::Serialization::Local::SetEstopEnabledCommandResult *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::SetEstopEnabledCommandResult>() const {
  return payload_as_SetEstopEnabledCommandResult();
}

template<> inline const OpenShock::Serialization::Local::SetEstopPinCommandResult *HubToLocalMessage::payload_as<OpenShock::Serialization::Local::SetEstopPinCommandResult>() const {
  return payload_as_SetEstopPinCommandResult();
}

struct HubToLocalMessageBuilder {
  typedef HubToLocalMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payload_type(OpenShock::Serialization::Local::HubToLocalMessagePayload payload_type) {
    fbb_.AddElement<uint8_t>(HubToLocalMessage::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(HubToLocalMessage::VT_PAYLOAD, payload);
  }
  explicit HubToLocalMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HubToLocalMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HubToLocalMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HubToLocalMessage> CreateHubToLocalMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    OpenShock::Serialization::Local::HubToLocalMessagePayload payload_type = OpenShock::Serialization::Local::HubToLocalMessagePayload::NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  HubToLocalMessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

struct HubToLocalMessage::Traits {
  using type = HubToLocalMessage;
  static auto constexpr Create = CreateHubToLocalMessage;
};

inline bool VerifyHubToLocalMessagePayload(::flatbuffers::Verifier &verifier, const void *obj, HubToLocalMessagePayload type) {
  switch (type) {
    case HubToLocalMessagePayload::NONE: {
      return true;
    }
    case HubToLocalMessagePayload::ReadyMessage: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::ReadyMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToLocalMessagePayload::ErrorMessage: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::ErrorMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToLocalMessagePayload::WifiScanStatusMessage: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiScanStatusMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToLocalMessagePayload::WifiNetworkEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiNetworkEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToLocalMessagePayload::WifiGotIpEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiGotIpEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToLocalMessagePayload::WifiLostIpEvent: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::WifiLostIpEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToLocalMessagePayload::AccountLinkCommandResult: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::AccountLinkCommandResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToLocalMessagePayload::SetRfTxPinCommandResult: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::SetRfTxPinCommandResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToLocalMessagePayload::SetEstopEnabledCommandResult: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::SetEstopEnabledCommandResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HubToLocalMessagePayload::SetEstopPinCommandResult: {
      auto ptr = reinterpret_cast<const OpenShock::Serialization::Local::SetEstopPinCommandResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyHubToLocalMessagePayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<HubToLocalMessagePayload> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyHubToLocalMessagePayload(
        verifier,  values->Get(i), types->GetEnum<HubToLocalMessagePayload>(i))) {
      return false;
    }
  }
  return true;
}

inline const OpenShock::Serialization::Local::HubToLocalMessage *GetHubToLocalMessage(const void *buf) {
  return ::flatbuffers::GetRoot<OpenShock::Serialization::Local::HubToLocalMessage>(buf);
}

inline const OpenShock::Serialization::Local::HubToLocalMessage *GetSizePrefixedHubToLocalMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OpenShock::Serialization::Local::HubToLocalMessage>(buf);
}

inline bool VerifyHubToLocalMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OpenShock::Serialization::Local::HubToLocalMessage>(nullptr);
}

inline bool VerifySizePrefixedHubToLocalMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OpenShock::Serialization::Local::HubToLocalMessage>(nullptr);
}

inline void FinishHubToLocalMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::HubToLocalMessage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedHubToLocalMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OpenShock::Serialization::Local::HubToLocalMessage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Local
}  // namespace Serialization
}  // namespace OpenShock

#endif  // FLATBUFFERS_GENERATED_HUBTOLOCALMESSAGE_OPENSHOCK_SERIALIZATION_LOCAL_H_
